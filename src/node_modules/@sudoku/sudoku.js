import solve from '@mattflow/sudoku-solver';
import { BOX_SIZE, GRID_LENGTH, SUDOKU_SIZE, GRID_COORDS } from '@sudoku/constants';
//import { getSudoku } from 'fake-sudoku-puzzle-generator';
import { makepuzzle, solvepuzzle, ratepuzzle } from "sudoku";

/**
 * @param {('veryeasy' | 'easy' | 'medium' | 'hard')} difficulty
 * @returns {number[][]}
 */

function chunkList(arr, len) {
  var chunks = [], i = 0, n = arr.length;
  while (i < n) {
    chunks.push(arr.slice(i, i += len));
  }
  return chunks;
}

export function generateSudoku(difficulty = 'easy') {
    var lower = -0.5;
    var upper = 0.5;
    switch(difficulty) {
        case 'hard':
            lower++;
            upper++;
        case 'medium':
            lower++;
            upper++;
        case 'easy':
            lower++;
            upper++;
    }
    
    do {
        var origpuzzle = makepuzzle();
        var rating = ratepuzzle(origpuzzle,20);
        //console.log(rating);
    } while (!(rating > lower && rating <= upper))
        
    const sudoku = chunkList(origpuzzle,9);//getSudoku(difficulty);
    //console.log(sudoku,ratepuzzle(origpuzzle,20),lower,upper);
	for (let row = 0; row < SUDOKU_SIZE; row++) {
		for (let col = 0; col < SUDOKU_SIZE; col++) {
			if (sudoku[row][col] === null) sudoku[row][col] = 0;
		}
	}

	return sudoku;
}


/**
 * @param {number[][]} sudoku
 */
export function solveSudoku(sudoku) {
	let grid = [
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
	];

	const solution = solve(sudoku.flat().join(''), {
		outputArray: true,
		hintCheck: false
	});

	for (let cell = 0; cell < GRID_LENGTH; cell++) {
		const [row, col] = GRID_COORDS[cell];
		grid[row][col] = solution[cell];
	}

	return grid;
}


/**
 * @param {number[][]} sudoku
 */
export function printSudoku(sudoku) {
	let out = '╔═══════╤═══════╤═══════╗\n';

	for (let row = 0; row < SUDOKU_SIZE; row++) {
		if (row !== 0 && row % BOX_SIZE === 0) {
			out += '╟───────┼───────┼───────╢\n';
		}

		for (let col = 0; col < SUDOKU_SIZE; col++) {
			if (col === 0) {
				out += '║ ';
			} else if (col % BOX_SIZE === 0) {
				out += '│ ';
			}

			out += (sudoku[row][col] === 0 ? '·' : sudoku[row][col]) + ' ';

			if (col === SUDOKU_SIZE - 1) {
				out += '║';
			}
		}

		out += '\n';
	}

	out += '╚═══════╧═══════╧═══════╝';

	console.log(out);
}